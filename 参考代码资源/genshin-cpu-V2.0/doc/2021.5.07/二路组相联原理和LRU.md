## 2路组相联

- 这篇笔记可能启发性不大

### 访存过程

根据主存地址种的cache组号找到对应的组，其中每个cache行都有对应的有效位V、标记Tag和数据Data。

1. 根据主存地址中的cache组号找到对应的组。
2. 将主存地址中的标记与对应组中每个行的标记Tag进行比较。
3. 将比较结果和有效位相“与”。
4. 若有一路比较相等 并且有效位为1，则输出”Hit“为1，并选中这一路cache行中的主存块。
5. 在”Hit“为1的情况下，根据主存地址中的块内地址从选中的一块内取出对应单元的信息。
6. 若”Hit“不为1，则CPU要到主存去读一块信息到cache中。
![二路组相联](https://img-blog.csdnimg.cn/20210507230707777.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZGRvbjIwMDE=,size_16,color_FFFFFF,t_70)


### LRU算法

#### （最近最少用算法）
​		LRU算法的基本思想是：总是选择近期最少使用的主存块被替换掉。这种算法能比较正地反映程序的访问局部性，因为当前最少使用的块一般来说也是将来最少被访问的。

​		采用LRU算法的每个 Cache行有一个**计数器**，用计数值来记录主存块的使用情况，通过硬件修改计数值，并根据计数值选择淘汰某个 cache行中的主存块。这计数值称为LRU位，其位数与cache组大小有关。2路组相联时有1位LRU位，4路组相联时有2位LRU位。
​		为简化上述LRU位计数的硬件实现，通常采用一种近似的LRU位计数方式来实现LRU算法。近似LRU计数方法仅区分哪些是新调入的主存块，哪些是较长时间未用的主存块，然后，在较长时间未用的块中选择一个被替换出去。
